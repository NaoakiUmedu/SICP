<!-- https://qiita.com/tbpgr/items/989c6badefff69377da7 -->
<!-- Ctrl-k v プレビュー -->
# SICP ノート
## 1.1 プログラミングの要素
- 基本式　言語に関わる最も単純な実体
- 組み合わせの方法 複合要素をより単純なものから構築する方法
- 抽象化の方法 復号要素に名前をつけ、単体として扱うための方法

### 1.1.1 式
インタプリタは式を入力するとその式の結果を表示する。<br>
(+ 137 34)...組み合わせ(手続の適用)<br>
(<演算子> <被演算子> ...)<br>
被演算子の値のことを引数という。

### 1.1.1 命名と環境
値がそのオブジェクトである変数を名前によって特定する。<br>
環境が名前とオブジェクトのペアを記録する。

### 1.1.3 組み合わせの評価
1. 組み合わせの部分式を評価する
2. 演算子の値となっている手続きを被演算子、つまり部分式の残り値に適用する
3. その名前の値は現在の環境でその名前に関連付けられたオブジェクトである
↑評価規則は再帰的となる 木の集積<br>
当てはまらないものは特殊形式と呼ばれる(defineとか)。

### 1.1.4 複合手続き
(define (<名前> <仮引数>)<br>
　　<本体>)

### 1.1.5 手続き適用の置換モデル
インタプリタは組み合わせの各要素を評価し、手続きの本体に出てくる仮引数を対応する引数で置き換えて、それを評価する。

#### [適用順序評価基準]
引数を評価してから適用する。
```
(f 5)
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square 6) (square 10))
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
```
#### [正規評価順序]
被演算子の式を基本演算子しか出てこな式に置き換えてから評価する。
```
(f 5)
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2))) 
(+ (* (+ 5 1) (+ 5 1)) (* (+ 5 2) (+ 5 2)))
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
```

### 1.1.6 条件式と述語
```
(cond	(<p1> <e1>)
		(<p2> <e2>)
		...
		(<p2> <e2>))
	(<pi> <ei>)...節
	<p> 述語(predicate)
	<e> 結果式(consequent expression)
```
if, and, or, not

### 1.1.7 ニュートン法による平方根
関数と手続きの違いは、物事の属性について説明することと、どうやって物事を行うかについて説明することの一般的な違いを反映したもの(宣言的知識と命令的知識)。

#### ニュートン法による平方根
<b>再帰的</B>とは、手続がそれ自身を使って定義されていること。<br>
手続定義は詳細を隠せるようになっていなければならない<B>(手続き抽象)</B>。<br>
<B>仮引数</B>とはプログラム中で関数やメソッドを呼び出して実行する際、関数側で値を受け取るために宣言された変数のこと。<br>
仮引数の名前は<B>束縛変数(bound variable)</B>と呼ばれ、手続き定義は仮引数を<B>束縛(bind)する</B>といった言い方をする。<br>
束縛変数が手続き定義の中で一貫性をもって改名された場合、手続の意味は変わらない。<br>
もし変数が束縛されていなければ、それは<B>自由(free)</B>であると言う。<br>
束縛によって名前が定義される式のセットはその名前の<B>スコープ(scope)</B>と言う。手続き定義においては、その手続の仮引数として宣言された束縛変数は、その手続の本体をスコープとして持っている。

#### 内部定義とブロック構造
手続きの仮引数はその手続の本体に局所化される(名前を分離する方法)。<br>
定義のネスト(<b>ブロック構造</b>)によるパッケージング
```
(define (xxxx x)
    (define (yyyy y))
    (define (zzzz z))
    (yyyy x)
    ...
    )
```

## 1.2 手続とそれが生成するプロセス
手続きは計算プロセスの<b>局所展開(local evolution)</b>のためのパターン。<br>
ではプロセスの全体的(グローバル)なふるまいについては?

### 1.2.1 線形再帰と反復
#### 線形再帰プロセス
```
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720
```

#### 線形反復プロセス
<b>schemeでは</b>こちらは(fact-iter a b c)
のa, b, cだけリソースを確保できれば良い
```
(factorial 6)
(fact-iter 1 1 6)
(fact-iter 1 2 6)
(fact-iter 2 3 6)
(fact-iter 6 4 6)
(fact-iter 24 5 6)
(fact-iter 120 6 6)
(fact-iter 720 7 6)
720
```

### 1.2.2 木の再帰
